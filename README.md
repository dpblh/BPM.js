## BPM.js engine

В основе BPM.js лежит граф потока управления(CFG).
CFG поддерживает асинхронное взаимодействие.

Система плагинов позволяет управлять потоком управления. Принимая на вход исходящие ребра(edge) и принимая решения куда будет переход или регистрируя обработчики.
По умолчанию переход происходит по единственному верному пути и запуску асинхронных контекстов.

### Scheme

Либо атомарна и должна реализовать методы:
1)

```js
const handler = (getVar, setVar, args) => ({
  result: args.a + args.b,
  status: 'done'|'await',
})
```

аргументы метода:
```const getVar = (name) => ...``` - получение значения переменной из контекста
```const setVar = (name, value) => ...``` - установка значения переменной в контекст
```args``` - переменные, переданные через ребро в вершину

2)
```js
const behavior = ({
  outgoingSimpleEdge,
  outgoingImmediateEdges,
  context,
  event,
  next,
  done,
}) => next()|done();
```

либо сохраненная комплексная схема

### Ребро(Edge)

Поведение у edge может быть двух типов: синхронные и асинхронные.
Синхронный edge может быть выбран только один, в то время как асинхронных edges может быть несколько.
Edge содержит условие перехода и правила настройки контекста

condition - имеет синтаксис схожий с выражениями в javaScript (за исключением равенства, все равенства являются строгими)
пример балансировки по нечетным значениям:
```js
i % 2 == 1
```
roles - настройка контекста, проставление переменных
пример проставления переменных контекста:
```js
a = a + 1 // поиск переменной `a` осуществляется вверх области видимости, если не находится переменная, она проставляется глобальной
var b = 5 // определяется в текущей области видимости
```

пример проставления переменных контекста по условию:
```js
if (i % 3 == 1) {
  if (x == 0) {
    x == -10
  }
  a = 10
} else if (i % 3 == 2) {
  a = 9
} else {
  a = 8
}
```

пример чтения результата выполнения предыдущей вершины:
```js
yield a // где `a` наименование переменной, куда будет сетиться результат
```

пример проставления аргументов:
```js
args({
  a:1, // `a` & `b` именованные аргументы вершины (getVar, setVar, `args`))
  b:2
})
```

### Вершина(Node)

Node наследует поведение scheme, переопределяя name & desc.
Node на вход передаются аргументы, на выходе ожидается результат и один из статусов done|await
`done` - завершает выполнение node и переходит к следующему
`await` - останавливает контекст до запуска его из вне.

### Пример CFG

main контекст A -> (...B -> C) -> D
B -> C будет выполняться, пока переменная i не будет больше 10

A -> B1 & A -> B2 запустятся асинхронно и соединятся в вершине С1(т.к. имеет обьединяющее поведение) -> D1

![Пример CFG](https://preview.ibb.co/deYJy7/2018_02_11_21_16_11.png)

### Диаграмма Гантта

![Диаграмма Гантта](https://image.ibb.co/eN9oWS/2018_02_11_21_24_36.png)


### Ближайшие улучшения

Поддержка плагинов (как на серверной стороне, так и на клиентской)
Проваливание вглубь по схемам
Добавить возможность указывать версию схемы при использовании её, как части большей схемы

